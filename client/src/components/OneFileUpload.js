import React, { useState } from 'react';
import jsPDF from 'jspdf';
import axios from 'axios';
import jsPDF from 'jspdf';
import './OneFileUpload.css';

const OneFileUpload = () => {
  const [file, setFile] = useState(null);
  const [loading, setLoading] = useState(false);
  const [stage, setStage] = useState(0);
  const [reportGenerated, setReportGenerated] = useState(false);
  const [similarSongs, setSimilarSongs] = useState([]);
  const [uploadError, setUploadError] = useState(null);

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);
  };

  const handleUpload = async () => {
    if (!file) return;
    const formData = new FormData();
    formData.append('file', file);
    setLoading(true);
    setStage(1); // Trigger Preprocessing animation
    try {
      const response = await axios.post('http://localhost:5000/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      setSimilarSongs(response.data.similarClips.slice(0, 10)); // Only show top 10 matches
      setLoading(false);
      setStage(2); // Stop Preprocessing animation
      setReportGenerated(true);
      setSimilarSongs([
        { name: "Song A", similarity: "85%", path: "songA.mp3" },
        { name: "Song B", similarity: "78%", path: "songB.mp3" },
      ]);
    } catch (error) {
      console.error('Error uploading files:', error);
      setLoading(false);
      setStage(0); // Reset stage on error
    }
  };

  const handleGenerateReport = async () => {
    const doc = new jsPDF();
    const userId = localStorage.getItem('userId');
    const date = new Date().toLocaleDateString();
    const songName = file ? file.name : "Unknown";
    const pageHeight = doc.internal.pageSize.height;
    
    // Fetch username from the server (assuming an API endpoint exists)
    let username = "User";

    // Calculate the average similarity score as the final score
    const totalScore = similarSongs.slice(0, 10).reduce((acc, song) => acc + parseFloat(song.similarity_score), 0);
    const finalScore = (totalScore / Math.min(similarSongs.length, 10)).toFixed(2) + "%";

    const checkPageOverflow = (currentYPos, lineHeight = 10) => {
        if (currentYPos + lineHeight >= pageHeight) {
            doc.addPage();
            return 20;
        }
        return currentYPos;
    };

    // Header Section
    doc.setFontSize(16);
    doc.setTextColor(0, 102, 204); // Blue color for the heading
    doc.text('SPECTRAL INSPECTOR', 105, 20, { align: 'center' });

    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0); // Black for normal text
    doc.text(`This report is generated by ${username} on ${date}`, 20, 40);
    doc.text(`Category: Audio Signature Match`, 20, 50);
    doc.text(`Final Score: ${finalScore}`, 20, 60);

    // Your Clip Section
    doc.setFontSize(14);
    doc.setTextColor(0, 102, 204); // Heading color
    doc.text('YOUR CLIP', 20, 80);

    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0);
    doc.text(`This clip is from the song: ${songName}`, 20, 90);

    // Plagiarized Segments Found Section
    doc.setFontSize(14);
    doc.setTextColor(0, 102, 204); // Heading color
    doc.text('TOP 10 PLAGIARIZED SEGMENTS FOUND', 20, 110);

    let yPos = 120;
    similarSongs.slice(0, 10).forEach((song, index) => {
        yPos = checkPageOverflow(yPos);

        // Check if clip_path exists and is a string before using match
        let startTime = "Unknown";
        let endTime = "Unknown";
        
        if (song.clip_path && typeof song.clip_path === 'string') {
            const clipDetails = song.clip_path.match(/-(\d+)-(\d+)\.mp3$/);
            if (clipDetails) {
                startTime = clipDetails[1];
                endTime = clipDetails[2];
            } else {
                console.warn(`No duration match found in clip path: ${song.clip_path}`);
            }
        } else {
            console.warn(`Invalid clip path: ${song.clip_path}`);
        }

        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        doc.text(`${index + 1}. Song: ${song.song_name}`, 20, yPos);
        yPos += 10;

        yPos = checkPageOverflow(yPos);
        doc.text(`Artist: ${song.artist}`, 20, yPos);
        yPos += 10;

        yPos = checkPageOverflow(yPos);
        doc.text(`Album: ${song.album}`, 20, yPos);
        yPos += 10;

        yPos = checkPageOverflow(yPos);
        doc.text(`Duration: ${startTime}-${endTime} seconds`, 20, yPos);
        yPos += 10;

        yPos = checkPageOverflow(yPos);
        doc.text(`Similarity Score: ${song.similarity_score}%`, 20, yPos);
        yPos += 10;

        // Draw a line after each song entry
        yPos = checkPageOverflow(yPos + 3);
        doc.setDrawColor(200, 200, 200); // Light grey for lines
        doc.line(20, yPos, 190, yPos); // Draw line
        yPos += 5;
    });

    const pdfBlob = doc.output('blob');
    const formData = new FormData();
    formData.append('report', pdfBlob, 'report.pdf');
    formData.append('userId', userId);

    try {
        const response = await axios.post('http://localhost:5000/upload-report', formData, {
            headers: {
                'Content-Type': 'multipart/form-data'
            }
        });
        console.log(response.data.message);
        setUploadError(null);
    } catch (error) {
        console.error('Error uploading report:', error);
        setUploadError('Error uploading report');
    }

    doc.save('report.pdf');
};

return (
  <div className="one-file-container">
    <div className="one-file-upload-box">
      <h1 className="one-file-h1">Audio Signature Matching</h1>
      <p>Upload an MP3 song to check for potential matches in our library. Weâ€™ll show you the top 10 matches!</p>
      
      <div className="file-input">
        <label>
          <input type="file" accept=".mp3" onChange={handleFileChange} style={{ display: 'none' }} disabled={loading} />
          <button
      className="one-file-button"
      onClick={() => !loading && document.querySelector('input[type="file"]').click()}
      disabled={loading} // Disable button during loading
      style={{ opacity: loading ? 0.5 : 1 }} // Dim button when loading
    >Select File</button>
        </label>
      </div>

      {file && <p>Selected file: {file.name}</p>}
      
      {/* Button with loading state */}
      <div>
        <button 
          className="one-file-button" 
          onClick={handleUpload} 
          disabled={loading} // Disable button while loading
        >
          Check Plagiarism
        </button>
      </div>
      
      {/* Message prompting the user to wait while loading */}
      {loading && <p>Please wait, your file is currently being processed...</p>}

      {stage === 1 && (
        <div className="stage">
          <div className="one-file-loading-bar"></div>
          <p>Processing...</p>
        </div>
      )}

      {!loading && reportGenerated && (
        <div className="one-file-results">
          <h2 className="one-file-h2">Top 10 Similar Songs</h2>
          <p>Download the report for a detailed analysis</p>
          {similarSongs.map((song, index) => (
            <div key={index} className="one-file-song">
              <div className="one-file-song-info">
                <p className="one-file-song-title">
                  {song.song_name} - {song.artist} - {song.album}
                </p>
                <p className="one-file-similarity-score">
                  Similarity Score: {song.similarity_score}%
                </p>
              </div>
              <audio controls className="one-file-audio">
                <source 
                  src={`http://localhost:5000/audio?path=${song.clip_path}`} 
                  type="audio/mp3" 
                />
                Your browser does not support the audio element.
              </audio> 
            </div>
          ))}
          <button onClick={handleGenerateReport}>View Report</button>
        </div>
      )}
    </div>
  </div>
);
};

export default OneFileUpload;
